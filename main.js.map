{"version":3,"file":"main.js","sources":["../consts:pathPrefix","../src/page/utils/num.ts","../src/page/utils/link.ts","../node_modules/unistore/dist/unistore.es.js","../src/page/state/store.ts","../src/page/load.ts","../src/page/location/marker.ts","../src/worker/promise-worker.ts","../src/page/location/closest-stop.ts","../consts:closestStopWorker","../src/page/state/map.ts","../src/page/location/locate-user.ts","../src/page/main.ts","../src/page/utils/date.ts","../src/page/sidebar.ts"],"sourcesContent":["export default \"/big-island-buses/\"","export const toInt = (n: string) => Number.parseInt(n, 10);\n","import pathPrefix from 'consts:pathPrefix';\n\nexport const enum Type {\n  ROUTE,\n  STOP,\n  TRIP,\n}\n\ninterface State {\n  route: {\n    id?: string | null;\n    trip?: string | null;\n  };\n  stop?: string | null;\n}\n\nexport interface Linkable {\n  Type: Type;\n  Value: string;\n}\n\nexport function getLinkState(state: State) {\n  return { route: state.route, stop: state.stop };\n}\n\n/**\n * Generates a link for href values. Meant to maintain whatever active data is avaliable.\n * @param {Type} type  \t\tType of item to change\n * @param {string} value \tID to change\n * @return {string} URL to use for href, based on active object.\n */\nexport function createLink(type: Type, value: string, state: State) {\n  let url = pathPrefix;\n  switch (type) {\n    case Type.ROUTE:\n      url += `routes/${value}/`;\n\n      if (state.route.trip != null) {\n        url += state.route.trip;\n      }\n\n      if (state.stop != null) {\n        url += `?stop=${state.stop}`;\n      }\n      break;\n    case Type.STOP:\n      return `?stop=${value}`;\n    case Type.TRIP:\n      url += `routes/${state.route.id}/${value}`;\n      if (state.stop != null) {\n        url += `?stop=${state.stop}`;\n      }\n      break;\n    default:\n      console.warn('Invalid type provided for link: %i', type);\n      break;\n  }\n  return url;\n}\n\n/**\n * Slices off the fragment from the string and returns the result.\n * Null is returned if the fragment does not exist in the string.\n * @param str Full string\n * @param fragment Part to slice off\n */\nfunction sliceOff(str: string, fragment: string) {\n  const idx = str.indexOf(fragment);\n  if (idx > -1) {\n    return str.substring(idx + fragment.length);\n  } else {\n    return null;\n  }\n}\n\n/**\n * Group 1: Route name\n * Group 2: Trip name\n */\nconst LINK_FORMAT = new RegExp(pathPrefix + 'routes/([\\\\w-]+)/(\\\\w+)?');\n\n/**\n * Parse a link. Handles the current /route/<name>/<trip> format and\n * the older query parameters in hash syntax.\n * Returns the corresponding state object.\n */\nexport function parseLink(url: URL): State {\n  const query =\n    sliceOff(url.hash, '#!') ||\n    sliceOff(url.search, '_escaped_fragment_')?.replace(/%26/g, '&');\n  if (query) {\n    const params = new URLSearchParams(query);\n    return {\n      route: {\n        id: params.get('route'),\n        trip: params.get('trip'),\n      },\n      stop: params.get('stop'),\n    };\n  }\n\n  const path = url.pathname.match(LINK_FORMAT);\n  const stop = url.searchParams.get('stop');\n  if (path) {\n    const [, route, trip] = path;\n    return {\n      route: {\n        id: route,\n        trip,\n      },\n      stop,\n    };\n  } else {\n    return {\n      route: {},\n      stop,\n    };\n  }\n}\n\nexport function getStateWithLink(state: State, type: Type, value: string) {\n  const newState = getLinkState(state);\n  switch (type) {\n    case Type.STOP:\n      newState.stop = value;\n      break;\n    case Type.ROUTE:\n      newState.route = { id: value, trip: state.route.trip };\n      break;\n    case Type.TRIP:\n      newState.route = { id: state.route.id, trip: value };\n      break;\n  }\n  return newState;\n}\n","function n(n,t){for(var r in t)n[r]=t[r];return n}export default function(t){var r=[];function u(n){for(var t=[],u=0;u<r.length;u++)r[u]===n?n=null:t.push(r[u]);r=t}function e(u,e,f){t=e?u:n(n({},t),u);for(var i=r,o=0;o<i.length;o++)i[o](t,f)}return t=t||{},{action:function(n){function r(t){e(t,!1,n)}return function(){for(var u=arguments,e=[t],f=0;f<arguments.length;f++)e.push(u[f]);var i=n.apply(this,e);if(null!=i)return i.then?i.then(r):r(i)}},setState:e,subscribe:function(n){return r.push(n),function(){u(n)}},unsubscribe:u,getState:function(){return t}}}\n//# sourceMappingURL=unistore.es.js.map\n","import createStore, { Store } from 'unistore';\n\ntype PromiseValue<T> = T extends Promise<infer R> ? R : T;\n\ntype PromiseValues<T> = {\n  readonly [P in keyof T]: PromiseValue<T[P]>;\n};\n\nexport const enum View {\n  LIST,\n\n  MAP_PRIMARY,\n  STREET_PRIMARY,\n}\n\nexport const enum LocationPermission {\n  NOT_ASKED = -1,\n  GRANTED = 0,\n  DENIED = 1,\n  UNAVALIABLE = 2,\n  TIMEOUT = 3,\n}\n\nexport type LatLngLiteral = google.maps.ReadonlyLatLngLiteral;\n\nexport interface State {\n  route: {\n    id?: string | null;\n    trip?: string | null;\n  };\n  stop?: string | null;\n  view: {\n    route: View;\n    stop: View;\n  };\n  locatePermission: LocationPermission;\n  userLocation?: LatLngLiteral;\n  searchLocation?: LatLngLiteral;\n  focus: 'user' | 'search' | 'stop';\n}\n\nexport const store = createStore<State>({\n  route: {},\n  view: {\n    route: View.LIST,\n    stop: View.MAP_PRIMARY,\n  },\n  locatePermission: LocationPermission.NOT_ASKED,\n  focus: 'stop',\n});\n\nexport function memoize<Func extends (...args: any[]) => any>(fn: Func): Func {\n  let lastArgs: Parameters<Func> | undefined;\n  let lastResult: ReturnType<Func> | undefined;\n  return function(...args: Parameters<Func>) {\n    if (lastArgs?.every((arg, i) => arg === args[i])) {\n      return lastResult;\n    }\n\n    lastArgs = args;\n    lastResult = fn(...args);\n    return lastResult;\n  } as Func;\n}\n\nfunction differentObjects<T>(a: T, b: T) {\n  return (Object.keys(a) as Array<keyof T>).some(key => a[key] === b[key]);\n}\n\n/**\n * Like Promise.all, but for objects with promises in the values.\n */\nfunction awaitObject<T>(obj: T) {\n  const keys = Object.keys(obj) as Array<keyof T>;\n  return Promise.all(keys.map(key => obj[key])).then(values => {\n    const result: Partial<T> = {};\n    keys.forEach((key, i) => {\n      result[key] = values[i];\n    });\n    return result as PromiseValues<T>;\n  });\n}\n\nexport function connect<Props>(\n  store: Store<State>,\n  mapStateToProps: (state: State) => Props,\n  callback: (props: PromiseValues<Props>) => void,\n) {\n  let lastProps: PromiseValues<Props> | undefined;\n  return store.subscribe(state =>\n    awaitObject(mapStateToProps(state)).then(props => {\n      if (!lastProps || differentObjects(props, lastProps)) {\n        lastProps = props;\n        callback(props);\n      }\n    }),\n  );\n}\n","/**\n * Contains construstors and helper functions.  Avoids using the DOM for functions.\n * @author       Tiger Oakes <tigeroakes@gmail.com>\n * @copyright    2014 Tiger Oakes\n */\n\nimport pathPrefix from 'consts:pathPrefix';\nimport { GTFSData, Trip } from '../gtfs-types';\nimport { toInt } from './utils/num';\nimport {\n  createLink,\n  Type,\n  Linkable,\n  getStateWithLink,\n  getLinkState,\n} from './utils/link';\nimport { store, connect, State } from './state/store';\nimport { Store } from 'unistore';\n\nnavigator.serviceWorker?.register(pathPrefix + 'service-worker.js');\n\nconst PIN_URL = pathPrefix + 'assets/pins.png';\n\nexport const normal = {\n    url: PIN_URL,\n    size: { height: 26, width: 24 },\n    scaledSize: { height: 26, width: 120 },\n    origin: { x: 0, y: 0 },\n    anchor: { x: 12, y: 12 },\n  } as google.maps.Icon,\n  unimportant = {\n    url: PIN_URL,\n    size: { height: 26, width: 24 },\n    scaledSize: { height: 26, width: 120 },\n    origin: { x: 96, y: 0 },\n    anchor: { x: 12, y: 12 },\n  } as google.maps.Icon,\n  userShape = {\n    url: PIN_URL,\n    size: { height: 26, width: 24 },\n    scaledSize: { height: 26, width: 120 },\n    origin: { x: 48, y: 0 },\n    anchor: { x: 12, y: 12 },\n  } as google.maps.Icon,\n  placeShape = {\n    url: PIN_URL,\n    size: { height: 26, width: 24 },\n    scaledSize: { height: 26, width: 120 },\n    origin: { x: 72, y: 0 },\n    anchor: { x: 12, y: 23 },\n  } as google.maps.Icon,\n  stopShape = {\n    url: PIN_URL,\n    size: { height: 26, width: 24 },\n    scaledSize: { height: 26, width: 120 },\n    origin: { x: 24, y: 0 },\n    anchor: { x: 12, y: 20 },\n  } as google.maps.Icon;\n\n/**\n * Grabs the API data and parses it into a GTFSData object for the rest of the program.\n */\nexport function getScheduleData(): Promise<GTFSData> {\n  return fetch(pathPrefix + 'api.json')\n    .then(res => {\n      if (res.ok) return res.json();\n      throw new Error(res.statusText);\n    })\n    .then(json => json as GTFSData);\n}\n\nexport function createElement<Tag extends keyof HTMLElementTagNameMap>(\n  type: Tag,\n  props: Partial<HTMLElementTagNameMap[Tag]>,\n) {\n  return Object.assign(document.createElement(type), props);\n}\n\n/**\n * Creates a promise version of the document load event\n * @return {Promise<DocumentReadyState>} resolves if document has loaded\n */\nexport function documentLoad() {\n  if (\n    document.readyState === 'interactive' ||\n    document.readyState === 'complete'\n  ) {\n    return Promise.resolve(document.readyState);\n  }\n\n  return new Promise(resolve => {\n    document.addEventListener('readystatechange', () => {\n      if (document.readyState === 'interactive') {\n        resolve(document.readyState);\n      }\n    });\n  });\n}\n\n/**\n * Generates a link for href values. Meant to maintain whatever active data is avaliable.\n * @param {Type} type  \t\tType of item to change\n * @param {string} value \tID to change\n * @return {string} URL to use for href, based on active object.\n */\nfunction pageLink(type: Type, value: string) {\n  return createLink(type, value, store.getState());\n}\n\ntype DynamicLinkNode = HTMLAnchorElement & Linkable;\n\n/**\n * Converts an A element into an automatically updating link.\n * @param type What value to change in link\n * @param value Value to use\n * @param store If given, used to update the link when state changes\n * @return A element with custom properties\n */\nexport function convertToLinkable(\n  node: HTMLAnchorElement,\n  type: Type,\n  value: string,\n  store?: Store<State>,\n) {\n  Object.assign(node, {\n    Type: type,\n    Value: value,\n    href: pageLink(type, value),\n  });\n  node.href = pageLink(type, value);\n  node.addEventListener('click', clickEvent);\n  if (store) {\n    connect(store, getLinkState, state => {\n      node.href = createLink(type, value, state);\n    });\n  }\n\n  return node;\n}\n\n/**\n * Creates an A element with custom click events for links.  Can update itself.\n * @param type What value to change in link\n * @param value Value to use\n * @param store If given, used to update the link when state changes\n * @return A element with custom properties\n */\nexport function dynamicLinkNode(\n  type: Type,\n  value: string,\n  store?: Store<State>,\n) {\n  const node = document.createElement('a') as DynamicLinkNode;\n  return convertToLinkable(node, type, value, store);\n}\n\n/**\n * Navigate to the page described by the `Linkable`.\n */\nexport function openLinkable(link: Linkable) {\n  const { Type, Value } = link;\n  const newLink = pageLink(Type, Value);\n  const newState = getStateWithLink(store.getState(), Type, Value);\n  store.setState(newState);\n  history.pushState(newState, null as any, newLink);\n  ga?.('send', 'pageview', { page: newLink, title: document.title });\n}\n\n/**\n * Used for the click event of a dynamicLinkNode\n * @param  {Event} e\n */\nexport function clickEvent(this: Linkable, e: Event) {\n  e.preventDefault?.();\n  e.stopPropagation?.();\n  openLinkable(this);\n  return false;\n}\n\n/**\n * Sorts stop time keys\n * @param {GTFSData stop_times} stopTimes\n * @return ordered list\n */\nexport function sequence(stopTimes: Trip['stop_times']): string[] {\n  const stopSequence = [];\n  for (const key in stopTimes) {\n    stopSequence.push(key);\n  }\n  return stopSequence.sort((a, b) => toInt(a) - toInt(b));\n}\n","import { Stop } from '../../gtfs-types';\nimport { clickEvent } from '../load';\nimport { LinkableMarker } from '../main';\nimport { LatLngLiteral } from '../state/store';\nimport { Type } from '../utils/link';\n\nexport function createLocationMarker(\n  options: google.maps.ReadonlyMarkerOptions,\n) {\n  let marker: LinkableMarker | undefined;\n  return (\n    map: google.maps.Map,\n    location: LatLngLiteral,\n    stop_id?: Stop['stop_id'],\n  ) => {\n    if (!marker) {\n      marker = new google.maps.Marker(options) as LinkableMarker;\n      marker.setMap(map);\n      marker.Type = Type.STOP;\n\n      google.maps.event.addListener(marker, 'click', clickEvent);\n    }\n\n    marker.Value = stop_id!;\n    marker.setPosition(location);\n\n    return marker;\n  };\n}\n","let messageIds = 0;\n\nexport class PromiseWorker {\n  callbacks = new Map<number, (error: Error | null, result: unknown) => void>();\n\n  constructor(private worker: Worker) {\n    worker.addEventListener('message', evt => this.onMessage(evt.data));\n  }\n\n  private onMessage(message: unknown) {\n    if (!Array.isArray(message) || message.length < 2) {\n      // Ignore - this message is not for us.\n      return;\n    }\n\n    const [messageId, error, result] = message;\n    const callback = this.callbacks.get(messageId);\n\n    if (!callback) {\n      // Ignore - user might have created multiple PromiseWorkers.\n      // This message is not for us.\n      return;\n    }\n\n    this.callbacks.delete(messageId);\n\n    callback(error, result);\n  }\n\n  postMessage(userMessage: unknown) {\n    const messageId = messageIds++;\n    const messageToSend = [messageId, userMessage];\n\n    return new Promise((resolve, reject) => {\n      this.callbacks.set(messageId, (error, result) => {\n        if (error) reject(error);\n        else resolve(result);\n      });\n\n      this.worker.postMessage(messageToSend);\n    });\n  }\n}\n","import url from 'consts:closestStopWorker';\nimport pathPrefix from 'consts:pathPrefix';\nimport { LatLngLike } from 'spherical-geometry-js';\nimport { GTFSData, Stop } from '../../gtfs-types';\nimport { PromiseWorker } from '../../worker/promise-worker';\n\nconst worker = new PromiseWorker(new Worker(pathPrefix + url));\n\nlet sentStops = false;\n\n/**\n * Find the closest stop to the user's location or searched place.\n * @param stops List of stops from API.\n * @param state Location of user and/or search place.\n */\nexport function findClosestStop(\n  stops: GTFSData['stops'],\n  location?: LatLngLike,\n): Promise<Stop | undefined> {\n  if (!location) return Promise.resolve(undefined);\n\n  if (!sentStops) {\n    worker.postMessage({ stops: Object.values(stops) });\n    sentStops = true;\n  }\n\n  return worker.postMessage(location) as Promise<Stop | undefined>;\n}\n","export default \"worker/closest-stop.js\"","import { GTFSData, Stop } from '../../gtfs-types';\nimport { findClosestStop } from '../location/closest-stop';\nimport { memoize, State } from './store';\n\nconst getClosestToUser = memoize(findClosestStop);\nconst getClosestToSearch = memoize(findClosestStop);\n\nexport function closestToUser(stops: GTFSData['stops'], state: State) {\n  return getClosestToUser(stops, state.userLocation);\n}\n\nexport function closestToSearch(stops: GTFSData['stops'], state: State) {\n  return getClosestToSearch(stops, state.searchLocation);\n}\n\nfunction getStopId(stop: Stop | undefined) {\n  return stop?.stop_id;\n}\n\nexport function stopToDisplay(stops: GTFSData['stops'], state: State) {\n  return Promise.resolve().then(() => {\n    switch (state.focus) {\n      case 'user':\n        return closestToUser(stops, state).then(getStopId);\n      case 'search':\n        return closestToSearch(stops, state).then(getStopId);\n      case 'stop':\n        return state.stop || undefined;\n    }\n  });\n}\n","import { Store } from 'unistore';\nimport { State, LocationPermission } from '../state/store';\n\nlet watchId: number = 0;\n\n/**\n * Start watching the user positon and update the store.\n */\nexport function locateUser(store: Store<State>) {\n  let firstPosition = true;\n  navigator.geolocation.clearWatch(watchId);\n  watchId = navigator.geolocation.watchPosition(\n    function onsuccess({ coords }) {\n      let newState: Partial<State> = {\n        locatePermission: LocationPermission.GRANTED,\n        userLocation: { lat: coords.latitude, lng: coords.longitude },\n      };\n      if (firstPosition) {\n        newState.focus = 'user';\n        firstPosition = false;\n      }\n      store.setState(newState as State);\n    },\n    function onerror(error) {\n      store.setState({ locatePermission: error.code as LocationPermission });\n    },\n  );\n}\n","/**\n * Contains code to build UI. Interacts with DOM.\n * @author       Tiger Oakes <tigeroakes@gmail.com>\n * @copyright    2014 Tiger Oakes\n */\n\nimport { GTFSData, Route, Stop, Trip } from '../gtfs-types.js';\nimport {\n  clickEvent,\n  createElement,\n  documentLoad,\n  dynamicLinkNode,\n  getScheduleData,\n  normal,\n  placeShape,\n  sequence,\n  stopShape,\n  unimportant,\n  userShape,\n} from './load.js';\nimport { createLocationMarker } from './location/marker.js';\nimport { hydrateAside } from './sidebar.js';\nimport { closestToSearch, closestToUser, stopToDisplay } from './state/map.js';\nimport { connect, LatLngLiteral, memoize, store, View } from './state/store.js';\nimport {\n  gtfsArrivalToDate,\n  gtfsArrivalToString,\n  nowDateTime,\n  stringTime,\n} from './utils/date.js';\nimport { Linkable, parseLink, Type } from './utils/link.js';\nimport { toInt } from './utils/num.js';\n\nlet map: google.maps.Map | undefined;\nlet streetview: google.maps.StreetViewPanorama | undefined;\nlet autocomplete: google.maps.places.Autocomplete | undefined;\nlet boundsAllStops: google.maps.LatLngBounds | undefined;\nlet markers: StopMarker[] = [];\nlet stopMarker: google.maps.Marker | undefined;\n\nconst documentPromise = documentLoad();\nconst schedulePromise = getScheduleData();\nconst mapPromise = loadMap();\n\n/*\nschedulePromise.then(api => {\n  window.api = api;\n  window.store = store;\n});\n*/\n\nexport type LinkableMarker = google.maps.Marker & Linkable;\ninterface StopMarker extends LinkableMarker {\n  stop_id: string;\n  activeInRoute?: boolean;\n}\n\n// Update map when location changes\nPromise.all([schedulePromise, mapPromise]).then(([schedule, map]) => {\n  interface Props {\n    stop?: Stop;\n    location?: LatLngLiteral;\n    buildMarker: ReturnType<typeof createLocationMarker>;\n  }\n\n  function updateMarker({ location, stop, buildMarker }: Props) {\n    if (location) buildMarker(map, location, stop?.stop_id);\n  }\n\n  const buildUserMarker = createLocationMarker({\n    title: 'My Location',\n    icon: userShape,\n    animation: google.maps.Animation.DROP,\n    zIndex: 1000,\n  });\n  const buildPlaceMarker = createLocationMarker({\n    title: 'Search Location',\n    icon: placeShape,\n    animation: google.maps.Animation.DROP,\n    zIndex: 1000,\n  });\n\n  connect(\n    store,\n    state => ({\n      location: state.userLocation,\n      stop: closestToUser(schedule.stops, state),\n      buildMarker: buildUserMarker,\n    }),\n    updateMarker,\n  );\n  connect(\n    store,\n    state => ({\n      location: state.searchLocation,\n      stop: closestToSearch(schedule.stops, state),\n      buildMarker: buildPlaceMarker,\n    }),\n    updateMarker,\n  );\n});\n\n// Create sidebar, and update it when nearby routes changes\nPromise.all([\n  schedulePromise,\n  documentPromise.then(hydrateAside),\n]).then(([schedule, connectStore]) => connectStore(schedule, store));\n\nfunction stopToPos(stop: Stop) {\n  return new google.maps.LatLng(\n    parseFloat(stop.stop_lat),\n    parseFloat(stop.stop_lon),\n  );\n}\n\nfunction loadMap() {\n  if (\n    !navigator.onLine ||\n    typeof google !== 'object' ||\n    typeof google.maps !== 'object'\n  ) {\n    documentPromise.then(function() {\n      document.body.classList.add('no-map');\n    });\n    throw new Error('Google Maps API has not loaded');\n  }\n  boundsAllStops = new google.maps.LatLngBounds();\n  markers = [];\n\n  function markersAndLatLng(schedule: GTFSData) {\n    return Promise.resolve().then(() => {\n      for (const stop of Object.values(schedule.stops)) {\n        const marker = new google.maps.Marker({\n          position: stopToPos(stop),\n          title: stop.stop_name,\n          icon: normal,\n        }) as StopMarker;\n        marker.Type = Type.STOP;\n        marker.Value = stop.stop_id;\n        marker.stop_id = stop.stop_id;\n        google.maps.event.addListener(marker, 'click', clickEvent);\n        boundsAllStops!.extend(marker.getPosition()!);\n        markers.push(marker);\n      }\n      return {\n        markers: markers,\n        bounds: boundsAllStops!,\n      };\n    });\n  }\n\n  function mapLoad() {\n    return Promise.resolve().then(() => {\n      const stopView = store.getState().view.stop;\n      const mapElement =\n        stopView === View.MAP_PRIMARY\n          ? document.getElementById('map-canvas')!\n          : document.getElementById('streetview-canvas')!;\n      const panoElement =\n        stopView === View.STREET_PRIMARY\n          ? document.getElementById('map-canvas')!\n          : document.getElementById('streetview-canvas')!;\n\n      map = new google.maps.Map(mapElement, {\n        center: new google.maps.LatLng(19.6, -155.56),\n        zoom: 10,\n        mapTypeControlOptions: {\n          position: google.maps.ControlPosition.TOP_CENTER,\n        },\n        panControlOptions: {\n          position: google.maps.ControlPosition.RIGHT_TOP,\n        },\n        streetViewControlOptions: {\n          position: google.maps.ControlPosition.RIGHT_TOP,\n        },\n        zoomControlOptions: {\n          position: google.maps.ControlPosition.RIGHT_TOP,\n        },\n      });\n\n      streetview = new google.maps.StreetViewPanorama(panoElement, {\n        position: new google.maps.LatLng(19.723835, -155.084741),\n        visible: true,\n        pov: { heading: 34, pitch: 0 },\n        scrollwheel: false,\n        panControlOptions: {\n          position: google.maps.ControlPosition.RIGHT_CENTER,\n        },\n        zoomControlOptions: {\n          style: google.maps.ZoomControlStyle.SMALL,\n          position: google.maps.ControlPosition.RIGHT_CENTER,\n        },\n        addressControl: false,\n      });\n      map.setStreetView(streetview!);\n\n      autocomplete = new google.maps.places.Autocomplete(\n        document.getElementById('search') as HTMLInputElement,\n      );\n      autocomplete.bindTo('bounds', map);\n      google.maps.event.addListener(autocomplete, 'place_changed', function() {\n        const place = autocomplete!.getPlace();\n        if (!place.geometry) return;\n        store.setState({\n          searchLocation: place.geometry.location.toJSON(),\n          focus: 'search',\n        });\n      });\n      return map;\n    });\n  }\n\n  const mapReady = documentPromise.then(mapLoad);\n\n  Promise.all([mapReady, schedulePromise.then(markersAndLatLng)]).then(\n    function([map, { markers, bounds }]) {\n      map.setCenter(bounds.getCenter());\n      map.fitBounds(bounds);\n      google.maps.event.addListener(map, 'bounds_changed', function() {\n        const mapBounds = map.getBounds()!;\n        for (const marker of markers) {\n          if (mapBounds.contains(marker.getPosition()!)) {\n            if (marker.getMap() !== map) marker.setMap(map);\n          } else {\n            marker.setMap(null);\n          }\n        }\n      });\n      markers.forEach(marker => marker.setMap(map));\n    },\n  );\n\n  window.addEventListener('resize', function() {\n    google.maps.event.trigger(map, 'resize');\n    google.maps.event.trigger(streetview, 'resize');\n    if (!store.getState().route.id) {\n      map!.setCenter(boundsAllStops!.getCenter());\n      map!.fitBounds(boundsAllStops!);\n    }\n  });\n\n  return mapReady;\n}\n\ndocumentPromise.then(function() {\n  uiEvents();\n});\n\nschedulePromise.then(schedule => {\n  function openActive(props: {\n    route_id?: string;\n    trip_id?: string;\n    stop_id?: string;\n  }) {\n    let routePromise = Promise.resolve();\n    if (props.route_id) {\n      routePromise = openRoute(schedule, props.route_id).then(bestTrip =>\n        openTrip(schedule, props.route_id, props.trip_id ?? bestTrip!),\n      );\n    }\n\n    if (props.stop_id) openStop(schedule, props.route_id, props.stop_id);\n\n    return routePromise;\n  }\n\n  connect(\n    store,\n    state => ({\n      route_id: state.route.id || undefined,\n      trip_id: state.route.trip || undefined,\n      stop_id: stopToDisplay(schedule.stops, state),\n    }),\n    openActive,\n  );\n});\n\nif (window.history.state) {\n  store.setState(window.history.state);\n} else {\n  const state = parseLink(new URL(location.href));\n  store.setState(state);\n}\nwindow.onhashchange = () => {\n  const state = parseLink(new URL(location.href));\n  store.setState(state);\n};\nwindow.onpopstate = (evt: PopStateEvent) => {\n  store.setState(evt.state);\n};\n\n/**\n * Adds click events to buttons in the site.\n */\nfunction uiEvents() {\n  if (!navigator.onLine) {\n    document.getElementById('main')!.classList.add('offline');\n  }\n  document\n    .getElementById('map-toggle')!\n    .addEventListener('click', switchMapStreetview);\n  const select = document.getElementById('trip-select') as HTMLSelectElement &\n    Linkable;\n  select.Type = Type.TRIP;\n  select.addEventListener('change', function(e) {\n    select.Value = select.options[select.selectedIndex].value;\n    clickEvent.call(select, e);\n  });\n\n  function toggleSidebar() {\n    document.getElementById('aside')!.classList.toggle('open');\n  }\n  document\n    .getElementById('screen-cover')!\n    .addEventListener('click', toggleSidebar);\n  document.getElementById('menu')!.addEventListener('click', toggleSidebar);\n  document.getElementById('alt-menu')!.addEventListener('click', toggleSidebar);\n}\n\nfunction removeChildren(parent: HTMLElement) {\n  while (parent.firstChild) parent.removeChild(parent.firstChild);\n}\n\n/**\n * Swaps map and streetview divs\n * @return {[type]} [description]\n */\nfunction switchMapStreetview(this: HTMLElement) {\n  if (!map || !streetview) {\n    console.error('Map and StreetViewPanorama have not loaded');\n    throw new TypeError();\n  }\n\n  const mapParent = document.getElementById('map')!;\n  const panoParent = document.getElementById('streetview-header')!;\n\n  const view = { ...store.getState().view };\n\n  if (view.stop === View.MAP_PRIMARY) {\n    mapParent.insertBefore(\n      document.getElementById('streetview-canvas')!,\n      mapParent.firstChild,\n    );\n    panoParent.insertBefore(\n      document.getElementById('map-canvas')!,\n      mapParent.firstChild,\n    );\n    this.classList.add('on');\n    view.stop = View.STREET_PRIMARY;\n  } else if (view.stop === View.STREET_PRIMARY) {\n    mapParent.insertBefore(\n      document.getElementById('map-canvas')!,\n      mapParent.firstChild,\n    );\n    panoParent.insertBefore(\n      document.getElementById('streetview-canvas')!,\n      mapParent.firstChild,\n    );\n    this.classList.remove('on');\n    view.stop = View.MAP_PRIMARY;\n  }\n  store.setState({ view });\n}\n\n/**\n * Creates a route UI and opens the section if the map is currently in fullscreen mode.\n * @param  {string} route_id ID of the route\n * @return {Promise<string>} trip_id that can be used in openTrip. Best matches time and open stop, if any.\n */\nconst openRoute = memoize(function openRoute(\n  buses: GTFSData,\n  route_id: Route['route_id'],\n): Promise<string | undefined> {\n  const thisRoute = buses.routes[route_id];\n  if (!thisRoute || !thisRoute.route_id) {\n    console.error('Invalid Route %s', route_id);\n    return Promise.resolve(undefined);\n  }\n\n  document.title = `${thisRoute.route_long_name} | Big Island Buses`;\n\n  const container = document.getElementById('content')!;\n  container.style.setProperty('--route-color', `#${thisRoute.route_color}`);\n  container.style.setProperty(\n    '--route-text-color',\n    `#${thisRoute.route_text_color}`,\n  );\n\n  const name = document.getElementById('route_long_name')!;\n  name.textContent = thisRoute.route_long_name;\n\n  let firstStop: Stop['stop_id'] | undefined;\n  let lastStop: Stop['stop_id'] | undefined;\n  let largest = 0;\n  let earliest = new Date(0, 0, 0, 23, 59, 59, 0);\n  let latest = new Date(0, 0, 0, 0, 0, 0, 0);\n  let earliestTrip: Trip['trip_id'] | undefined;\n  let earliestTripStop: Stop['stop_id'] | undefined;\n\n  const nowTime = nowDateTime();\n  let closestTrip: Trip['trip_id'] | undefined;\n  let closestTripTime = Number.MAX_VALUE;\n  let closestTripStop: Stop['stop_id'] | undefined;\n  const select = document.getElementById('trip-select')!;\n  removeChildren(select);\n\n  const routeStops = new Set<Stop['stop_id']>();\n\n  for (const trip_id of Object.keys(thisRoute.trips)) {\n    const trip = thisRoute.trips[trip_id];\n    for (const stop in trip.stop_times) {\n      if (stop == '1' && toInt(trip.direction_id) === 0) {\n        firstStop = trip.stop_times[stop].stop_id;\n      } else {\n        if (toInt(stop) > largest && toInt(trip.direction_id) === 0) {\n          largest = toInt(stop);\n          lastStop = trip.stop_times[stop].stop_id;\n        }\n      }\n\n      routeStops.add(trip.stop_times[stop].stop_id);\n\n      const timeDate = gtfsArrivalToDate(trip.stop_times[stop].arrival_time);\n      if (timeDate > latest) {\n        latest = timeDate;\n      }\n      if (timeDate < earliest) {\n        earliest = timeDate;\n        earliestTrip = trip.trip_id;\n        earliestTripStop = trip.stop_times[stop].stop_id;\n      }\n\n      if (\n        timeDate.getTime() - nowTime.getTime() < closestTripTime &&\n        timeDate.getTime() - nowTime.getTime() > 0\n      ) {\n        closestTripTime = timeDate.getTime() - nowTime.getTime();\n        closestTrip = trip.trip_id;\n        closestTripStop = trip.stop_times[stop].stop_id;\n      }\n    }\n    if (!closestTrip) {\n      //Too late for all bus routes\n      closestTripTime =\n        new Date(\n          0,\n          0,\n          1,\n          earliest.getHours(),\n          earliest.getMinutes(),\n          earliest.getSeconds(),\n          0,\n        ).getTime() - nowTime.getTime();\n      closestTrip = earliestTrip;\n      closestTripStop = earliestTripStop;\n    }\n    const option = createElement('option', {\n      value: trip.trip_id,\n      textContent: trip.trip_short_name,\n    });\n    select.appendChild(option);\n  }\n\n  const minString =\n    Math.floor(closestTripTime / 60000) != 1\n      ? Math.floor(closestTripTime / 60000) + ' minutes'\n      : '1 minute';\n  document.getElementById('place-value')!.textContent =\n    'Between ' +\n    buses!.stops[firstStop!].stop_name +\n    ' - ' +\n    buses!.stops[lastStop!].stop_name;\n  document.getElementById('time-value')!.textContent =\n    stringTime(earliest) + ' - ' + stringTime(latest);\n  document.getElementById('next-stop-value')!.textContent =\n    'Reaches ' + buses!.stops[closestTripStop!].stop_name + ' in ' + minString;\n\n  document.getElementById('main')!.classList.add('open');\n\n  if (\n    navigator.onLine &&\n    typeof google === 'object' &&\n    typeof google.maps === 'object'\n  ) {\n    const routeBounds = new google.maps.LatLngBounds();\n    for (const marker of markers) {\n      if (routeStops.has(marker.stop_id)) {\n        marker.setIcon(normal);\n        marker.setZIndex(200);\n        marker.activeInRoute = true;\n        routeBounds.extend(marker.getPosition()!);\n      } else {\n        marker.setIcon(unimportant);\n        marker.setZIndex(null);\n        marker.activeInRoute = false;\n      }\n    }\n    if (stopMarker) {\n      stopMarker.setIcon(stopShape);\n      stopMarker.setZIndex(300);\n    }\n\n    google.maps.event.trigger(map, 'resize');\n    map!.setCenter(routeBounds.getCenter());\n    map!.fitBounds(routeBounds);\n    google.maps.event.trigger(streetview, 'resize');\n  }\n\n  return Promise.resolve(closestTrip);\n});\n\n/**\n * Creates a Stop fragment in the #stop element\n * @param  {[type]} stop_id Id of the stop to use\n * @return {void}           Creates an element\n */\nfunction openStop(\n  buses: GTFSData,\n  currentRoute: Route['route_id'] | null | undefined,\n  stop_id: Stop['stop_id'],\n) {\n  const thisStop = buses.stops[stop_id];\n  if (!thisStop || !thisStop.stop_id) {\n    console.error('Invalid Stop %s', stop_id);\n    return;\n  }\n\n  if (streetview) {\n    streetview.setPosition(stopToPos(thisStop));\n  }\n  if (map) {\n    for (const marker of markers) {\n      if (marker.activeInRoute || currentRoute == null) {\n        marker.setIcon(normal);\n      } else {\n        marker.setIcon(unimportant);\n      }\n      if (marker.stop_id === thisStop.stop_id) {\n        stopMarker = marker;\n      }\n    }\n\n    stopMarker!.setIcon(stopShape);\n    stopMarker!.setZIndex(300);\n\n    streetview!.setPosition(stopMarker!.getPosition()!);\n    google.maps.event.trigger(streetview, 'resize');\n    google.maps.event.addListener(streetview!, 'pano_changed', function() {\n      document.getElementById(\n        'address',\n      )!.textContent = streetview!.getLocation().description!;\n      streetview!.setPov(streetview!.getPhotographerPov());\n    });\n  }\n  if (!streetview) {\n    document.getElementById('stop')!.classList.add('no-streetview');\n  }\n\n  document.getElementById('stop_name')!.textContent = thisStop.stop_name;\n\n  const list = document.getElementById('connections')!;\n  removeChildren(list);\n  for (const route_id of thisStop.routes) {\n    const route = buses.routes[route_id];\n    const linkItem = dynamicLinkNode(Type.ROUTE, route_id);\n    linkItem.className = 'connections__link';\n    linkItem.style.borderColor = `#${route.route_color}`;\n    linkItem.textContent = route.route_long_name;\n\n    const listItem = document.createElement('li');\n    listItem.className = 'connections__item';\n    listItem.append(linkItem);\n    if (currentRoute === route_id) {\n      listItem.classList.add('connections__item--active-route');\n    }\n    list.append(listItem);\n  }\n\n  document.getElementById('main')!.classList.add('open-stop');\n}\n\nfunction openTrip(\n  buses: GTFSData,\n  route_id: Route['route_id'] | null | undefined,\n  trip_id: Trip['trip_id'],\n) {\n  const route = buses.routes[route_id!];\n  if (!route) {\n    console.error('Invalid Route %s', route_id);\n    return;\n  }\n  const trip = route.trips[trip_id];\n  if (!trip || !trip.trip_id) {\n    console.error('Invalid trip %s in route %s', trip_id, route_id);\n    return;\n  }\n\n  const schedule = document.getElementById('schedule')!;\n  removeChildren(schedule);\n\n  const stopSequence = sequence(trip.stop_times);\n\n  const select = document.getElementById('trip-select') as HTMLSelectElement;\n  for (let option = 0; option < select.options.length; option++) {\n    if (select.options[option].value === trip_id) {\n      select.selectedIndex = option;\n      select.options[option].selected = true;\n      break;\n    }\n  }\n\n  document.getElementById('week-days-value')!.textContent =\n    buses.calendar[trip.service_id].text_name;\n\n  for (const sequence of stopSequence) {\n    const tripStop = trip.stop_times[sequence];\n    const routeListItem = dynamicLinkNode(Type.STOP, tripStop.stop_id);\n    routeListItem.className = 'schedule__stop';\n\n    const lines = createElement('div', { className: 'lines' });\n    for (let j = 0; j < 2; j++) {\n      const line = createElement('span', { className: 'line' });\n      lines.appendChild(line);\n    }\n    routeListItem.appendChild(lines);\n\n    const name = createElement('span', {\n      className: 'schedule__stopname name',\n      textContent: buses.stops[tripStop.stop_id].stop_name,\n    });\n    routeListItem.appendChild(name);\n\n    const time = createElement('time', {\n      className: 'schedule__time',\n      textContent: gtfsArrivalToString(tripStop.arrival_time),\n    });\n    routeListItem.appendChild(time);\n\n    schedule.appendChild(routeListItem);\n  }\n}\n","import { toInt } from './num.js';\n\n/**\n * Turns a date into a string with hours, minutes.\n * @param  {Date} \tdate Date to convert\n * @param  {string} date 24hr string in format 12:00:00 to convert to string in 12hr format\n * @return {string}    \tString representation of time\n */\nexport function stringTime(date: Date | string): string {\n  if (typeof date === 'string') {\n    if (date.indexOf(':') > -1 && date.lastIndexOf(':') > date.indexOf(':')) {\n      const [hour, min, second] = date.split(':').map(toInt);\n      date = new Date(0, 0, 0, hour, min, second, 0);\n    }\n  }\n  if (typeof date != 'object') {\n    throw new TypeError(`date must be Date or string, not ${typeof date}`);\n  }\n\n  let m = 'am';\n  let displayHour = '';\n  let displayMinute = '';\n  const hr = date.getHours();\n  const min = date.getMinutes();\n\n  if (hr === 0) {\n    displayHour = '12';\n  } else if (hr === 12) {\n    displayHour = '12';\n    m = 'pm';\n  } else if (hr > 12) {\n    const mathHr = hr - 12;\n    displayHour = mathHr.toString();\n    m = 'pm';\n  } else {\n    displayHour = hr.toString();\n  }\n\n  if (min === 0) {\n    displayMinute = '';\n  } else if (min < 10) {\n    displayMinute = ':0' + min.toString();\n  } else {\n    displayMinute = ':' + min.toString();\n  }\n\n  return displayHour + displayMinute + m;\n}\n\n/**\n * Returns a date object based on the string given\n * @param  {string} string in format 13:00:00, from gtfs data\n * @return {Date}\n */\nexport function gtfsArrivalToDate(string: string): Date {\n  const [hour, min, second] = string.split(':').map(s => toInt(s));\n  let extraDays = 0;\n  let extraHours = 0;\n  if (hour > 23) {\n    extraDays = Math.floor(hour / 24);\n    extraHours = hour % 24;\n  }\n  return new Date(0, 0, 0 + extraDays, hour + extraHours, min, second, 0);\n}\n\n/**\n * Combines stringTime() and gtfsArrivalToDate()\n * @param  {string} string in format 13:00:00, from gtfs data\n * @return {string}        String representation of time\n */\nexport function gtfsArrivalToString(string: string) {\n  return stringTime(gtfsArrivalToDate(string));\n}\n\n/**\n * Returns the current time, with date stripped out\n * @return {Date} Current time in hour, min, seconds; other params set to 0\n */\nexport function nowDateTime(): Date {\n  const now = new Date();\n  return new Date(\n    0,\n    0,\n    0,\n    now.getHours(),\n    now.getMinutes(),\n    now.getSeconds(),\n    0,\n  );\n}\n","import { Store } from 'unistore';\nimport { GTFSData } from '../gtfs-types';\nimport { convertToLinkable } from './load';\nimport { State, connect, LocationPermission, store } from './state/store';\nimport { Type } from './utils/link';\nimport { closestToUser } from './state/map';\nimport { locateUser } from './location/locate-user';\n\n/**\n * Hydrate the pre-rendered sidebar HTML.\n */\nexport function hydrateAside() {\n  const nearbyList = document.getElementById('nearby')!;\n  const otherList = document.getElementById('other')!;\n  const nearbyInfo = document.getElementById('nearby-info')!;\n\n  const routeListItems = new Map<string, HTMLLIElement>();\n  for (const child of otherList.children) {\n    const listItem = child as HTMLLIElement;\n    const route_id = listItem.dataset.route!;\n\n    const link = listItem.querySelector<HTMLAnchorElement>('a.routes__link')!;\n    convertToLinkable(link, Type.ROUTE, route_id, store);\n\n    routeListItems.set(route_id, listItem);\n  }\n\n  return function connectStore(schedule: GTFSData, store: Store<State>) {\n    // Start searching user location on click\n    nearbyInfo.addEventListener('click', () => locateUser(store));\n\n    connect(\n      store,\n      state => ({\n        permission: state.locatePermission,\n      }),\n      function showHideButton({ permission }) {\n        switch (permission) {\n          case LocationPermission.NOT_ASKED:\n            nearbyInfo.textContent = 'Find routes near my location >';\n            nearbyInfo.hidden = false;\n            break;\n          case LocationPermission.GRANTED:\n            nearbyInfo.hidden = true;\n            break;\n          case LocationPermission.DENIED:\n            nearbyInfo.textContent = 'Location permission denied.';\n            nearbyInfo.hidden = false;\n            break;\n          case LocationPermission.UNAVALIABLE:\n            nearbyInfo.textContent = 'Location search failed.';\n            nearbyInfo.hidden = false;\n            break;\n          case LocationPermission.TIMEOUT:\n            nearbyInfo.textContent = 'Location search timed out.';\n            nearbyInfo.hidden = false;\n            break;\n        }\n      },\n    );\n\n    connect(\n      store,\n      state => ({\n        nearest: closestToUser(schedule.stops, state),\n      }),\n      function updateNearbyRoutes({ nearest }) {\n        const nearbyRoutes = new Set(nearest?.routes ?? []);\n        for (const [route_id, listItem] of routeListItems) {\n          if (nearbyRoutes.has(route_id)) {\n            nearbyList.appendChild(listItem);\n          } else {\n            otherList.appendChild(listItem);\n          }\n        }\n      },\n    );\n  };\n}\n"],"names":["toInt","n","Number","parseInt","Type","getLinkState","state","route","stop","createLink","type","value","url","pathPrefix","ROUTE","trip","STOP","TRIP","id","console","warn","sliceOff","str","fragment","idx","indexOf","substring","length","LINK_FORMAT","RegExp","parseLink","query","hash","search","replace","params","URLSearchParams","get","path","pathname","match","searchParams","getStateWithLink","newState","t","r","View","LocationPermission","store","u","push","e","f","i","o","action","arguments","apply","this","then","setState","subscribe","unsubscribe","getState","createStore","view","LIST","MAP_PRIMARY","locatePermission","NOT_ASKED","focus","memoize","fn","lastArgs","lastResult","args","every","arg","connect","mapStateToProps","callback","lastProps","obj","keys","Object","Promise","all","map","key","values","result","forEach","awaitObject","props","a","b","some","differentObjects","navigator","serviceWorker","register","PIN_URL","normal","size","height","width","scaledSize","origin","x","y","anchor","unimportant","userShape","placeShape","stopShape","createElement","assign","document","pageLink","convertToLinkable","node","Value","href","addEventListener","clickEvent","dynamicLinkNode","preventDefault","stopPropagation","link","newLink","history","pushState","ga","page","title","openLinkable","createLocationMarker","options","marker","location","stop_id","google","maps","Marker","setMap","event","addListener","setPosition","messageIds","worker","[object Object]","Map","evt","onMessage","data","message","Array","isArray","messageId","error","callbacks","delete","userMessage","messageToSend","resolve","reject","set","postMessage","Worker","sentStops","findClosestStop","stops","undefined","getClosestToUser","getClosestToSearch","closestToUser","userLocation","closestToSearch","searchLocation","getStopId","stopToDisplay","streetview","autocomplete","boundsAllStops","watchId","stringTime","date","lastIndexOf","hour","min","second","split","Date","TypeError","m","displayHour","displayMinute","hr","getHours","getMinutes","toString","gtfsArrivalToDate","string","s","extraDays","extraHours","Math","floor","stopMarker","markers","documentPromise","readyState","schedulePromise","fetch","res","ok","json","Error","statusText","mapPromise","onLine","body","classList","add","LatLngBounds","mapReady","stopView","mapElement","getElementById","panoElement","STREET_PRIMARY","center","LatLng","zoom","mapTypeControlOptions","position","ControlPosition","TOP_CENTER","panControlOptions","RIGHT_TOP","streetViewControlOptions","zoomControlOptions","StreetViewPanorama","visible","pov","heading","pitch","scrollwheel","RIGHT_CENTER","style","ZoomControlStyle","SMALL","addressControl","setStreetView","places","Autocomplete","bindTo","place","getPlace","geometry","toJSON","schedule","stopToPos","stop_name","icon","extend","getPosition","bounds","setCenter","getCenter","fitBounds","mapBounds","getBounds","contains","getMap","window","trigger","loadMap","parseFloat","stop_lat","stop_lon","updateMarker","buildMarker","buildUserMarker","animation","Animation","DROP","zIndex","buildPlaceMarker","nearbyList","otherList","nearbyInfo","routeListItems","child","children","listItem","route_id","dataset","querySelector","firstPosition","geolocation","clearWatch","watchPosition","coords","GRANTED","lat","latitude","lng","longitude","code","locateUser","permission","textContent","hidden","DENIED","UNAVALIABLE","TIMEOUT","nearest","nearbyRoutes","Set","routes","has","appendChild","connectStore","switchMapStreetview","select","toggleSidebar","toggle","selectedIndex","call","uiEvents","trip_id","routePromise","openRoute","bestTrip","buses","trips","removeChildren","stopSequence","stopTimes","sort","sequence","stop_times","option","selected","calendar","service_id","text_name","tripStop","routeListItem","className","lines","j","line","name","time","arrival_time","openTrip","currentRoute","thisStop","activeInRoute","setIcon","setZIndex","getLocation","description","setPov","getPhotographerPov","list","linkItem","borderColor","route_color","route_long_name","append","openStop","URL","parent","firstChild","removeChild","mapParent","panoParent","insertBefore","remove","onhashchange","onpopstate","thisRoute","container","firstStop","lastStop","setProperty","route_text_color","earliestTrip","earliestTripStop","largest","earliest","latest","nowTime","now","getSeconds","nowDateTime","closestTrip","closestTripStop","closestTripTime","MAX_VALUE","routeStops","direction_id","timeDate","getTime","trip_short_name","minString","routeBounds"],"mappings":"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"}