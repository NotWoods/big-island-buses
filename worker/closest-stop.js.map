{"version":3,"file":"closest-stop.js","sources":["../../node_modules/spherical-geometry-js/src/utils.js","../../node_modules/spherical-geometry-js/src/latlng.js","../../node_modules/spherical-geometry-js/src/compute-distance-between.js","../../src/worker/closest-stop-worker.ts","../../src/worker/register.ts"],"sourcesContent":["/** @type {number} Earth's radius (at the Equator) of 6378137 meters. */\nexport const EARTH_RADIUS = 6378137;\n\nexport function toDegrees(radians) {\n    return (radians * 180) / Math.PI;\n}\n\nexport function toRadians(angleDegrees) {\n    return (angleDegrees * Math.PI) / 180.0;\n}\n","const LAT = 'latitude';\nconst LNG = 'longitude';\n\n/**\n * Converts an object into a LatLng. Tries a few different methods:\n * 1. If instanceof LatLng, clone and return the object\n * 2. If it has 'lat' and 'lng' properties...\n *    2a. if the properties are functions (like Google LatLngs),\n *        use the lat() and lng() values as lat and lng\n *    2b. otherwise get lat and lng, parse them as floats and try them\n * 3. If it has 'lat' and *'long'* properties,\n *    parse them as floats and return a LatLng\n * 4. If it has 'lat' and *'lon'* properties,\n *    parse them as floats and return a LatLng\n * 5. If it has 'latitude' and 'longitude' properties,\n *    parse them as floats and return a LatLng\n * 6. If it has number values for 0 and 1, use 1 as latitude and 0\n *    as longitude.\n * 7. If it has x and y properties, try using y as latitude and x and\n *    longitude.\n * @param {any} like\n * @returns {LatLng}\n */\nexport function convert(like) {\n    if (like instanceof LatLng) {\n        return new LatLng(like[LAT], like[LNG]);\n    } else if ('lat' in like && 'lng' in like) {\n        if (typeof like.lat == 'function' && typeof like.lng == 'function') {\n            return new LatLng(like.lat(), like.lng());\n        } else {\n            return new LatLng(parseFloat(like.lat), parseFloat(like.lng));\n        }\n    } else if ('lat' in like && 'long' in like) {\n        return new LatLng(parseFloat(like.lat), parseFloat(like.long));\n    } else if ('lat' in like && 'lon' in like) {\n        return new LatLng(parseFloat(like.lat), parseFloat(like.lon));\n    } else if ('latitude' in like && 'longitude' in like) {\n        return new LatLng(\n            parseFloat(like.latitude),\n            parseFloat(like.longitude)\n        );\n    } else if (typeof like[0] === 'number' && typeof like[1] === 'number') {\n        return new LatLng(like[1], like[0]);\n    } else if ('x' in like && 'y' in like) {\n        return new LatLng(parseFloat(like.y), parseFloat(like.x));\n    } else {\n        throw new TypeError(`Cannot convert ${like} to LatLng`);\n    }\n}\n\n/**\n * Comparison function\n * @param {LatLng} one\n * @param {LatLng} two\n * @returns {boolean}\n */\nexport function equals(one, two) {\n    one = convert(one);\n    two = convert(two);\n    return (\n        Math.abs(one[LAT] - two[LAT]) < Number.EPSILON &&\n        Math.abs(one[LNG] - two[LNG]) < Number.EPSILON\n    );\n}\n\nexport default class LatLng {\n    /**\n     * @param {number} lat\n     * @param {number} lng\n     * @param {boolean} noWrap\n     */\n    constructor(lat, lng, noWrap = false) {\n        lat = parseFloat(lat);\n        lng = parseFloat(lng);\n\n        if (Number.isNaN(lat) || Number.isNaN(lng)) {\n            throw TypeError('lat or lng are not numbers');\n        }\n\n        if (!noWrap) {\n            //Constrain lat to -90, 90\n            lat = Math.min(Math.max(lat, -90), 90);\n            //Wrap lng using modulo\n            lng = lng == 180 ? lng : ((((lng + 180) % 360) + 360) % 360) - 180;\n        }\n\n        Object.defineProperty(this, LAT, { value: lat });\n        Object.defineProperty(this, LNG, { value: lng });\n        this.length = 2;\n\n        Object.freeze(this);\n    }\n\n    /**\n     * Comparison function\n     * @param {LatLng} other\n     * @returns {boolean}\n     */\n    equals(other) {\n        return equals(this, other);\n    }\n\n    /**\n     * Returns the latitude in degrees.\n     * (I'd rather use getters but this is for consistency)\n     * @returns {number}\n     */\n    lat() {\n        return this[LAT];\n    }\n\n    /**\n     * Returns the longitude in degrees.\n     * (I'd rather use getters but this is for consistency)\n     * @returns {number}\n     */\n    lng() {\n        return this[LNG];\n    }\n\n    /** @type {number} alias for lng */\n    get x() {\n        return this[LNG];\n    }\n    /** @type {number} alias for lat */\n    get y() {\n        return this[LAT];\n    }\n    /** @type {number} alias for lng */\n    get 0() {\n        return this[LNG];\n    }\n    /** @type {number} alias for lat */\n    get 1() {\n        return this[LAT];\n    }\n    /** @type {number} alias for lng */\n    get long() {\n        return this[LNG];\n    }\n    /** @type {number} alias for lng */\n    get lon() {\n        return this[LNG];\n    }\n\n    /**\n     * Converts to JSON representation. This function is intended to be used via\n     * JSON.stringify.\n     * @returns {LatLngLiteral}\n     */\n    toJSON() {\n        return { lat: this[LAT], lng: this[LNG] };\n    }\n\n    /**\n     * Converts to string representation.\n     * @returns {string}\n     */\n    toString() {\n        return `(${this[LAT]}, ${this[LNG]})`;\n    }\n\n    /**\n     * Returns a string of the form \"lat,lng\" for this LatLng. We round the\n     * lat/lng values to 6 decimal places by default.\n     * @param {number} [precision=6]\n     * @returns {string}\n     */\n    toUrlValue(precision = 6) {\n        precision = parseInt(precision);\n        return (\n            parseFloat(this[LAT].toFixed(precision)) +\n            ',' +\n            parseFloat(this[LNG].toFixed(precision))\n        );\n    }\n\n    [Symbol.iterator]() {\n        let i = 0;\n        return {\n            next: () => {\n                if (i < this.length) {\n                    return { value: this[i++], done: false };\n                } else {\n                    return { done: true };\n                }\n            },\n            [Symbol.iterator]() {\n                return this;\n            },\n        };\n    }\n}\n","import { EARTH_RADIUS, toRadians } from './utils.js';\nimport { convert } from './latlng.js';\n\nexport function computeDistanceBetweenHelper(from, to) {\n    const radFromLat = toRadians(from.lat());\n    const radFromLng = toRadians(from.lng());\n    const radToLat = toRadians(to.lat());\n    const radToLng = toRadians(to.lng());\n    return (\n        2 *\n        Math.asin(\n            Math.sqrt(\n                Math.pow(Math.sin((radFromLat - radToLat) / 2), 2) +\n                    Math.cos(radFromLat) *\n                        Math.cos(radToLat) *\n                        Math.pow(Math.sin((radFromLng - radToLng) / 2), 2)\n            )\n        )\n    );\n}\n\n/**\n * Returns the distance, in meters, between to LatLngs. You can optionally\n * specify a custom radius. The radius defaults to the radius of the Earth.\n * @param {LatLng} from\n * @param {LatLng} to\n * @param {number} [radius]\n * @returns {number} distance\n */\nexport default function computeDistanceBetween(\n    from,\n    to,\n    radius = EARTH_RADIUS\n) {\n    from = convert(from);\n    to = convert(to);\n    return computeDistanceBetweenHelper(from, to) * radius;\n}\n","import { computeDistanceBetween, LatLngLike } from 'spherical-geometry-js';\nimport { Stop } from '../gtfs-types';\nimport { registerPromiseWorker } from './register';\n\nlet stops: readonly Stop[] | undefined;\n\n/**\n * Find the closest stop to the user's location or searched place.\n * @param stops List of stops from API.\n * @param state Location of user and/or search place.\n */\nfunction findClosestStop(location: LatLngLike) {\n  if (!stops) {\n    throw new Error('stops not ready');\n  }\n\n  let closestDistance = Number.MAX_VALUE;\n  let closestStop: Stop | undefined;\n\n  for (const stop of stops) {\n    const distance = computeDistanceBetween(location, {\n      lat: stop.stop_lat,\n      lng: stop.stop_lon,\n    });\n    if (distance < closestDistance) {\n      closestStop = stop;\n      closestDistance = distance;\n    }\n  }\n\n  return closestStop;\n}\n\nregisterPromiseWorker(message => {\n  if (message.stops) {\n    stops = message.stops;\n    return undefined;\n  } else {\n    return findClosestStop(message);\n  }\n});\n","export function registerPromiseWorker(\n  callback: (message: any) => Promise<unknown> | unknown,\n) {\n  function postOutgoingMessage(\n    messageId: number,\n    error: Error | null,\n    result?: unknown,\n  ) {\n    if (error) {\n      console.error('Worker caught an error:', error);\n      self.postMessage([messageId, error]);\n    } else {\n      self.postMessage([messageId, null, result]);\n    }\n  }\n\n  self.addEventListener('message', function onIncomingMessage(e) {\n    const payload = e.data;\n    if (!Array.isArray(payload) || payload.length !== 2) {\n      // message doens't match communication format; ignore\n      return;\n    }\n\n    const [messageId, message] = payload;\n\n    Promise.resolve(callback(message)).then(\n      result => postOutgoingMessage(messageId, null, result),\n      error => postOutgoingMessage(messageId, error),\n    );\n  });\n}\n"],"names":["EARTH_RADIUS","toRadians","angleDegrees","Math","PI","LAT","LNG","convert","like","LatLng","lat","lng","parseFloat","long","lon","latitude","longitude","y","x","TypeError","[object Object]","noWrap","Number","isNaN","min","max","Object","defineProperty","this","value","length","freeze","other","two","one","abs","EPSILON","0","1","precision","parseInt","toFixed","Symbol","iterator","i","next","done","computeDistanceBetween","from","to","radius","radFromLat","radFromLng","radToLat","radToLng","asin","sqrt","pow","sin","cos","computeDistanceBetweenHelper","stops","callback","postOutgoingMessage","messageId","error","result","console","self","postMessage","addEventListener","e","payload","data","Array","isArray","message","Promise","resolve","then","registerPromiseWorker","location","Error","closestStop","closestDistance","MAX_VALUE","stop","distance","stop_lat","stop_lon","findClosestStop"],"mappings":"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"}